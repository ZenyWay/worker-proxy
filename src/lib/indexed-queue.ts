/**
 * Copyright 2016 Stephane M. Catala
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * Limitations under the License.
 */
;
import newIndexGenerator,
{ IndexGenerator, isIndexGenerator } from './index-generator'
import { assert, isObject, isFunction } from './utils'
import debug = require('debug')
const log = debug('indexed-queue')

/**
 * @public
 * @param {IndexedQueueOpts} opts?
 * @return {IndexedQueue} instance
 */
export interface IndexedQueueFactory {
  (opts?: IndexedQueueOpts): IndexedQueue
}

export interface IndexedQueueOpts {
  /**
   * @public
   * @prop {IndexGenerator} index?
   */
  index?: IndexGenerator
}

/**
 * @public
 * @interface IndexedQueue
 * simple indexed queue that automatically generates indexes for pushed entries.
 * index values are any safe integer between `Number.MIN_SAFE_INTEGER`
 * and `Number.MAX_SAFE_INTEGER`.
 * a generated value is guaranteed not to collide
 * with the previous `Number.MAX_SAFE_INTEGER - Number.MAX_SAFE_INTEGER`.
 * @generic {T} type of queued values
 */
export interface IndexedQueue {
  /**
   * @public
   * @method pop
   * extract and return the entry indexed by the given `index`.
   * the entry is definitively removed from this `IndexedQueue`.
   * @param {number} index
   * @return {T} indexed entry
   * @error {Reference Error} 'invalid reference' when no arguments,
   * or when `index` is not a number or not in the queue
   */
  pop (index: number): any
	/**
   * @public
   * @method push
   * queue the given `val` and return its `index` index.
   * the returned index is generated by the {IndexGenerator}
   * specified at instantiation, or by the default internal {IndexGenerator}.
   * every push generates a new index, whether it succeeds or not.
	 * @param {T} val
	 * @return {number} index of queued `val`
   * @error {Reference Error} 'invalid reference' when no arguments
   * @error {Error} 'internal resource conflict for index ${index}'
   * when an entry is already queued at the generated index.
   * in this case, it is possible to push until a free index is found.
	 */
	push (val: any): number
  /**
   * @public
   * @method length
   * @return {number} length of queue
   */
  length (): number
  /**
   * @public
   * @method has
   * @param {number} index
   * @return {boolean} true when an entry is queued with the given `index`
   */
  has (index: number): boolean
}

/**
 * @public
 * @function IndexedQueueDuckTypable duck-type validation
 * @param {any} val
 * @return {val is IndexedQueue}
 */
export interface IndexedQueueDuckTypable {
  (val?: any): val is IndexedQueue
}

/**
 * @private
 * @class IndexedQueueClass
 * @implements implements IndexedQueue
 */
class IndexedQueueClass implements IndexedQueue {
  /**
   * @public
   * @see {IndexedQueueFactory}
   */
  static getInstance (opts?: IndexedQueueOpts): IndexedQueue {
    const index: IndexGenerator =
    isObject(opts) && isIndexGenerator((<any>opts).index) ?
    (<any>opts).index : newIndexGenerator()

    return new IndexedQueueClass(index)
  }
  /**
   * @public
   * @see {IndexedQueueDuckTypable}
   */
  static isIndexedQueue (val?: any): val is IndexedQueue {
    return isObject(val) &&
    [ val.pop, val.push, val.length, val.has ].every(isFunction)
  }

  constructor (public index: IndexGenerator) {}
  /**
   * @public
   * @see {IndexedQueue#pop}
   */
  pop (index: number): any {
    assert(this.has(index), ReferenceError, 'invalid reference')
  	const val = this._queue[index]
    delete this._queue[index]
    this._length--
    log('Queue.length', this._length)
    return val
  }
	/**
   * @public
   * @see {IndexedQueue#push}
	 */
	push (val: any): number {
    assert(!!arguments.length, ReferenceError, 'missing argument')

  	const index = this.index.next()
    assert(!this.has(index), Error,
    `internal resource conflict for index ${index}`)

  	this._queue[index] = val
    this._length++
    log('Queue.length', this._length)
    return index
  }
  /**
   * @public
   * @see {IndexedQueue#length}
   */
  length (): number {
    return this._length
  }
  /**
   * @public
   * @see {IndexedQueue#has}
   */
  has (index: number): boolean {
  	return (typeof index === 'number') && index in this._queue
  }
  /**
   * @private
   */
  _length = 0
  /**
   * @private
   */
  _queue = {}
}

export const isIndexedQueue: IndexedQueueDuckTypable =
IndexedQueueClass.isIndexedQueue

const newIndexedQueue: IndexedQueueFactory = IndexedQueueClass.getInstance
export default newIndexedQueue